<h1>Поле заголовка Content-Transfer-Encoding</h1>

<p><font color="#000000">Многие типы данных,
пересылаемых через email требуют
"натурального" представления,
то есть, 8-битный набор символов
либо двоичный код (что для машины -
одно и то же, только представимо для
пользователя по-разному). В таком
виде данные не могут быть пересланы
по 7-битным почтовым протоколам,
например, RFC 821, который, к тому же,
ограничивает длину строки 1000
символами. </font></p>

<p><font color="#000000">Стандартные
механизмы конвертирования почты в
7-битный короткострочный формат,
приемлимый для почтового
транспорта, описывает поле
заголовка Content-Transfer-Encoding. </font></p>

<p><font color="#000000">В отличие от типов
содержимого, увеличение множества
значений Content-Transfer-Encoding не является
необходимым и даже нежелательно. Но
установление единого механизма
конвертирования не представляется
возможным. Существует противоречие
между желанием эффективно
"ужать" бинарные данные и
желанием трансформировать данные,
которые, хотя бы частично являются
7-битным текстом, так, чтобы их
все-таки можно было читать. По этой
причине необходимы по крайней мере
2 механизма конвертации:
"читабельный" и "плотно
ужимающий". </font></p>

<p><font color="#000000">Данное поле не было
определено в предыдущих
стандартах. Его значение должно
быть строкой без пробелов,
определяющей тип конвертации, как
показано ниже: </font></p>

<pre><font color="#000000">   конвертация := "Content-Transfer-Encoding" ":" механизм
   механизм :=     "7bit"  ;
                  / "quoted-printable"
                  / "base64"
                  / "8bit"
                  / "binary"
                  / x-token</font></pre>

<p><font color="#000000">Значения не
чувствительны к регистру букв, то
есть, Base64, BASE64 и bAsE64 - одно и то же.
Значение "7BIT" означает, что
тело письма уже имеет 7-битный
формат и не тренбует
дополнительной обработки для
пересылки по почте. Это значение
полагается по умолчанию, если поле
заголовка Content-Transfer-Encoding
отсутствует. </font></p>

<p><font color="#000000">Значения "8bit",
"7bit" и "binary" означают, что
никакой трансформации содержимого
не производится. Однако, они
сделаны различными для индикации
того, что из себя представляет
содержимое письма, и,
соответственно, способа обработки,
который может потребоваться для
данной транспортной системы. В
частности: </font></p>

<p><font color="#000000"><strong>"7bit"</strong>
означает, что данные являются
текстом, имеют короткие строки и
языковую кодировку US-ASCII. </font></p>

<p><font color="#000000"><strong>"8bit"</strong>
означает короткие строки, но в них
могут содержаться не-ASCII символы
(128-255). </font></p>

<p><font color="#000000"><strong>"Binary"</strong>
означает, что тело письма может
содержать не-ASCII символы, но строки
могут быть произвольной длины, т.е.
слишком длинными для SMTP-транспорта,
и может несоблюдаться соглашение
по признаку конца строки (CRLF),
принятое в SMTP-транспорте. </font></p>

<p><font color="#000000">Хотя на первый взгляд
разница в значениях Content-Transfer-Encoding
может показатся неважной - ведь все
они означают, что никакого
преобразования нет, но четкая
разметка важна для почтовых шлюзов
между разными почтовыми системами,
имеющими разные возможности и
особенности работы, число которых
со временем растет. </font></p>

<p><font color="#000000">Спецификация на
почтовый транспорт для пересылки
некодированных 8-битных данных дана
в RFC-1426. Однако, нет
стандартизованных транспортов
рочты Internet, для которых является
приемлимым включение в тело письма
некодированных двоичных данных.
Таким образом, значение "binary"
фактически не является легальным в
Internet. Но в соответствии с MIME, при
использовании почтовой системой
транспорта, умеющего работать с
двоичными данными, в случае, когда
необходимо послать двоичные данные
по e-mail, необходимо указать это в
заголовке в поле Content-Transfer-Encoding. </font></p>

<p><font color="#000000">Пять значений,
определенных для поля
Content-Transfer-Encoding, ничего не говорят о
типе содержимого кроме указания
алгоритма кодирования либо
требований к почтовому транспорту
в случае некодированных данных. </font></p>

<p><font color="#000000">Производители
почтового ПО, если необходимо,
могут определить новые значения
поля Content-Transfer-Encoding, но эти значения
должны иметь префикс "X-"
("x-"), чтобы подчеркнуть их
нестандартный характер. Однако, в
отличие от типов и подтипов поля
Content-Type, введение новых значений
Content-Transfer-Encoding настоятельно не
рекомендуется, так как может
оказаться помехой для
взаимосовместимости почтовых
систем. Использование X-значений
позволяется только как результат
взаимосоглашения между
взаимодействующими системами. </font></p>

<p><font color="#000000">Если поле
Content-Transfer-Encoding появляеися в
заголовке тела какой-то части
письма, оно применяется только к
содержимому этой части. Если письмо
(часть письма) имеет тип "multipart"
или "message", то поле
Content-Transfer-Encoding может иметь в
качестве своего значения только
длину символа ("7bit", "8bit" и
т.д.) или "binary". </font></p>

<p><font color="#000000">Необходимо заметить.
что электронная почта является
символьно-ориентированной, так что
механизмы конвертации работают с
данными как с потоком символов, а не
битов. Если битовый поток должен
быть кодирован посредством
какого-либо из этих механизмов,
сначала он должен быть
конвертирован в 8-битный поток
байтов, используя порядок битов,
стандартный для сетей (старшие
разряды в конце). То есть, передние
биты в потоке становятся битами
высшего порядка в байте. Если
битовый поток оканчивается
неполным байтом, недостающие
разряды заполняются нулями. </font></p>

<p><font color="#000000">Все кодирующие
механизмы, определенные в
спецификации MIME, кодируют любые
данные в символьную форму. Так, к
примеру, полагая, что тело письма
(части письма) имеет поля заголовка
вроде: </font></p>

<pre><font color="#000000">     Content-Type: text/plain; charset=ISO-8859-1
     Content-transfer-encoding: base64</font></pre>

<p><font color="#000000">то это означает, что
тело письма представляет собой
ASCII-код base64 текстовых данных,
которые в нормальном виде имеют
языковую кодировку ISO-8859-1, и будут в
этой языковой кодировке после
декодирования. </font></p>

<p><font color="#000000">Все множество
определенных значений поля
content-transfer-encoding кроме начинающихся с
префикса "X-", зарезервировано
в IANA для будущего использования.
Частные соглашения по значениям
content-transfer-encoding также настоятельно
не рекомендуются. </font></p>

<p><font color="#000000">Некоторые значения
Content-transfer-encoding могут использоваться
только с определенными типами (поле
Content-Type). В частности, запрещено
использовать любые значения кроме
"7bit", "8bit", или "binary" с
любым типом, рекурсивно включающим
заголовки с полем Content-Type (как
правило, это типы "multipart" и
"message"). Все кодирования,
необходимые для содержимого тел
многочастного письма должны быть
произведены на более низком уровне.
</font></p>

<h4 align="center"><font color="#000000">Замечания по
ограничениям конвертации</font></h4>

<p><font color="#000000">Необходимо
предотвращать случаи вложенного
кодирования, когда данные проходят
через алгоритм конвертации
несколько раз и должны столько же
раз быть декодированы, чтобы быть
читаемыми. Вложенное кодирование
добавляет сложностей
пользовательским почтовым
программам: кроме очевидных
проблем с множественной
конвертацией, они могут скрыть
основную структуру письма. В
частности, они могут привести к
тому, что несколько операций по
декодированию могут потребоваться
только для того, чтобы определить,
объекты каких типов находятся в
письме. Запрещение вложенного
кодирования может осложнить работу
некоторых почтовых шлюзов, но это
будет меньшей проблемой по
сравнению с трудностями для
пользовательских почтовых
программ. </font></p>

<p><font color="#000000"><i>ЗАМЕЧАНИЕ ПО
ПЕРЕВОДУ КОДОВ:</i> Конверторы
quoted-printable и base64 разработаны так, что
данные после их применения легко
взаимоконвертируемы. Единственный
нюанс, возникающий в подобной
ретрансляции - признак конца
строки. При конвертации из quoted-printable
в base64 перевод строки должен быть
заменен последовательностью CRLF.
Соответственно и наоборот, но
ТОЛЬКО при конвертации текстовых
данных. </font></p>

<h4 align="center"><font color="#000000">Механизм
конвертации "Quoted-Printable"</font></h4>

<p><font color="#000000">Этот механизм
предназначен для представления
данных, в основном состоящих из
байтов, соответствующих символам,
имеющим изображение в символьном
наборе ASCII. В результате данного
кодирования все байты будут иметь
такие значения, гарантированные от
дальнейшей модификации почтовым
транспортом. Если конвертируемые
данные в основном представляют
собой ASCII-текст, то конечная их
форма остается узнаваемой и
читаемой для человека. Тело,
полностью состоящее из
ASCII-символов, также может быть
конвертироавано в Quoted-Printable, что
гарантирует его содержимому
целостность при прохождении через
всякие шлюзы, в которых происходит
языковая перекодировка символов
или преобразование концов строк и
т.д. </font></p>

<p><font color="#000000">В Quoted-Printable байты
должны быть рпедставлены в
соответствии со следующими
правилами: </font></p>

<p><font color="#000000"><i>ПРАВИЛО #1:</i>
(обычное 8-битное представление).
Каждый байт, кроме тех, которые
используются для обозначения конца
строки, может быть представлен с
помощью двух шестнадцатиричных
цифр, предворяемых знаком "=".
При написании шестнадцатиричных
цифр с A по F должны использоваться
заглавные буквы. Кроме тех случаев,
когда нижеследующие правила
позволяют альтернативное
кодирование, данное правило
является обязательным. </font></p>

<p><font color="#000000"><i>ПРАВИЛО #2:</i>
(Буквенное представление). Байты с
десятичным значением с 33 по 60 и с 62
по 126 МОГУТ быть представлены
ASCII-символами, соответствующими
этим значениям (с '!' по '&lt;' и с '&gt;' по
'~'). </font></p>

<p><font color="#000000"><i>ПРАВИЛО #3:</i>
(Пробелы): Байты со значениями 9 и 32
МОГУТ быть представлены как
ASCII-символы "Табуляция" и
"Пробел", но НЕ ДОЛЖНЫ быть
представлены так в конце строки.
Везде, где они представлены
соответствующими ASCII-символами, за
ними должен следовать символ,
имеющий графическое изображение
(печатный символ). В конце же строки
символы табуляции и пробела должны
быть представлены в соответствии с
правилом #1, так как некоторые
почтовые транспорты могут убирать
пробелы в конце строки. </font></p>

<p><font color="#000000"><i>ПРАВИЛО #4:</i> (Конец
строки): Конец строки в тексте
письма должен быть представлен (в
соответствии с RFC 822)
последовательностью CRLF. Так как в
каноническом представлении текста
не требуется визуального
отображения символов конца строки,
в Quoted-Printable не используется видимых
символов для обозначения конца
строки. Для представления бинарных
данных более предпочтительной
является кодировка base64. </font></p>

<p><font color="#000000">Необходимо заметить,
что многие реализации почтовых
программ могут кодировать
по-своему. В частности, при
представлеии текста в системах,
использующих другие соглашения по
обозначению конца строки (отличные
от CRLF). Такие реализации
недопустимы, и генерация концов
строки должна быть стандартизована
везде, чтобы не требовалось
распознавать, используется ли
какое-либо альтернативное
представление. </font></p>

<p><font color="#000000"><i>ПРАВИЛО #5:</i> (Мягкий
конец строки): В соответствии с
Quoted-Printable длина строки не должна
превышать 76 символов. В противном
случае используется 'мягкий'
перевод строки, представимый
знаком равенства. Например, если
исходная строка имела вид: </font></p>

<pre><font color="#000000">     Now's the time for all folk to come to the aid of
     their country.</font></pre>

<p><font color="#000000">то в Quoted-Printable encoding он
может быть представлена следующим
образом: </font></p>

<pre><font color="#000000">     Now's the time =
     for all folk to come=
     to the aid of their country.</font></pre>

<p><font color="#000000">Это обеспечивает
механизм восстановления исходной
длины строки пользовательским
почтовыи агентом. </font></p>

<p><font color="#000000">Поскольку символ
дефиса ("-") представляется в
Quoted-Printable в обычном виде, особую
осторожность нужно соблюдать при
заключении тела в Quoted-Printable в
многочастное письмо, чтобы
удостовериться, что граница этого
включения не проявляется нигде
внутри этого включения (лучше всего
выбрать обозначение границы в виде
последовательности символов
"=_", которая никогда не
появляется в теле, закодированном в
Quoted-Printable.) </font></p>

<p><font color="#000000"><i>ЗАМЕЧАНИЕ:</i>
Quoted-Printable представляет собой нечто
вроде компромисса между
читабельностью и сохранностью при
пересылке. Тела в Quoted-Printable будут
надежно защищены при прохождении
многих почтовых шлюзов, но могут
быть не очень хорошо переданы через
некоторые шлюзы, использующие
трансляцию в EBCDIC. (Теоретически,
EBCDIC-шлюз должен кодировать тело из
quoted-printable в base64 и затем декодировать
обратно, но таких шлюзов пока не
существует). Единственный способ
добится действительно надежной
транспортировки через EBCDIC-шлюз -
экранировать ASCII-символы </font></p>

<pre><font color="#000000">     !"#$@[\]^`{|}~</font></pre>

<p><font color="#000000">в соответствии с
правилом #1. </font></p>

<p><font color="#000000">Так как данные в
quoted-printable являются
строчно-ориентированными, можно
ожидать, что представление концов
строки в Quoted-Printable будет изменено
почтовым транспортом таким же
образом, как и обычный текст может
измениться при пересылке по
Internet-почте между системами с
разными соглашениями по
представлению концов строки. Если
подобные изменения могут нарушить
целостность данных, то имеет смысл
пользоваться кодировкой base64, а не
Quoted-Printable. </font></p>

<p><font color="#000000">Вниманию создателей
ПО: Если двоичные данные
пересылаются в Quoted-Printable, то надо
соблюдать осторожность при
кодировании символов CR и LF. В
частности, последовательность CRLF
должна быть представлена как
"=0D=0A", в противном случае, если
CRLF означает конец строки, то она
может быть неверно
интерпретирована в платформах с
другими соглашениями по концу
строки. </font></p>

<p><font color="#000000">Синтаксис данных в
quoted-printable описывается следующим
образом: </font></p>

<pre><font color="#000000">   quoted-printable := ([*(простой текст / ПРОБЕЛ / ТАБУЛЯЦИЯ) простой текст]
                        ["="] CRLF)
        ; Максимальная длина строки - 76 символов, включая CRLF
   простой текст := байт /&lt;любой ASCII-символ "=", ПРОБЕЛ или ТАБУЛЯЦИЯ&gt;
        ; символы, не перечисленные в приложении B к RFC 1521 как  безопас-
        ; ные для почты, также не рекомендуются к использованию
   байт := "=" 2(ФИФРА / "A" / "B" / "C" / "D" / "E" / "F")
        ; байт используется для символов &gt; 127, =, ПРОБЕЛ, или ТАБУЛЯЦИЯ,
        ; и рекомендуется для представления любых символов, не  перечислен-
        ; ных в приложении B к RFC 1521 как безопасные для почты</font></pre>

<h4 align="center"><font color="#000000">Механизм
конвертации Base64</font></h4>

<p><font color="#000000">Этот алгоритм
разработан для представления
произвольных последовательностей
байтов в форму, читаемую для
человека. Кодирующий и
декодирующий алгоритмы очень
просты, но закодированные данные
примерно на 33% больше, чем
некодированные. этот метод
идентичен тому, который
используется в приложениях PEM (Privacy
Enhanced Mail), описанной в RFC 1421 с одним
отличием: base64 не приемлит
встроенного "чистого" текста. </font></p>

<p><font color="#000000">Base64 использует
65-символьный поднабор из US-ASCII,
выделяя 6 бит на каждый печатный
символ. (65-й символ "="
используется для обозначения
функции спец. обработки). </font></p>

<p><font color="#000000"><i>ПРИМЕЧАНИЕ:</i> этот
поднабор имеет важное свойство: он
идентичен всем версиям языковой
кодировки ISO 646, включая US ASCII, а
также всем версиям EBCDIC. Другие
популярные механизмы кодирования
(uuencode, base85 - часть уровня 2 PostScript) не
разделяют этих свойств и поэтому не
удовлетворяют требованиям
переносимости для двоичных данных
электронной почты. </font></p>

<p><font color="#000000">Процесс кодирования
преобразует 4 входных символа в
виде 24-битной группы, обрабатывая
их слева направо. Эти группы затем
рассматриваются как 4 соединенные
6-битные группы, каждая из которых
транслируется в одиночную цифру
алфавита base64. При кодировании base64,
входной поток байтов должен быть
упорядочен старшими битами вперед. </font></p>

<p><font color="#000000">Каждая 6-битная группа
используется как индекс для
массива 64-х печатных символов.
Символ, на который указывает
значение индекса, помещается в
выходную строку. Эти символы
выбраны так, чтобы быть
универсально представимыми и
исключают символы, имеющие
специальное значение для
SMTP-транспорта (".", CR, LF) и для
синтаксиса вложенных тел MIME
("-"). </font></p>

<pre><font color="#000000">                        <strong>Таблица</strong> : Алфавит Base64
    Значение Код    Значение Код    Значение Код    Значение Код
           0 A            17 R            34 i            51 z
           1 B            18 S            35 j            52 0
           2 C            19 T            36 k            53 1
           3 D            20 U            37 l            54 2
           4 E            21 V            38 m            55 3
           5 F            22 W            39 n            56 4
           6 G            23 X            40 o            57 5
           7 H            24 Y            41 p            58 6
           8 I            25 Z            42 q            59 7
           9 J            26 a            43 r            60 8
          10 K            27 b            44 s            61 9
          11 L            28 c            45 t            62 +
          12 M            29 d            46 u            63 /
          13 N            30 e            47 v
          14 O            31 f            48 w            = (заполнитель)
          15 P            32 g            49 x
          16 Q            33 h            50 y</font></pre>

<p><font color="#000000">Выходной поток
(закодированные бфайты) должен
иметь длину строк не более 76
символов. Все признаки перевода
строки и другие символы,
отсутствующие в таблице 1, должны
быть проигнорированы декодером
base64. Среди данных в Base64 символы, не
перечисленные в табл. 1, переводы
строки и т.п. должны говорить об
ошибке передачи данных, и,
соответственно, почтовая программа
должна оповестить пользователя о
ней. </font></p>

<p><font color="#000000">Если в хвосте потока
кодируемых данных осталось меньше,
чем 24 бита, справа добавляются
нулевые биты до образования целого
числа 6-битных групп. А до конца
24-битной группы остается от 0 до 3-х
недостающих 6-битных групп, вместо
каждой из которых ставится
символ-заполнитель '='. Поскольку
весь входной поток представляет
собой целое число 8-битных групп
(т.е., просто байтных значений), то
возможны лишь следующие случаи: (1)
входной поток как раз оканчивается
24-битной группой. В таком случае,
выходной поток будет оканчиваться
четырьмя символами Base64 без символа
'='; (2) хвост входного потока имеет
длину 8 бит. Тогда в конце выходного
кода быдут два символа Base64, с
добавлением двух символов '='; (3)
хвост входного потока имеет длину 16
бит. Тогда в конце выходного будут
стоять три символа Base64 и один
символ '='. </font></p>

<p><font color="#000000">Т.к. символ '=' является
хвостовым заполнителем, его
появление в теле письма может
означать только то, что конец
данных достигнут. Но такой гарантии
нет, если число переданных битов
кратно 24. </font></p>

<p><font color="#000000">Любые бессмысленные
последовательности в коде Base64
вроде "=====" должны быть
игнорированы. </font></p>

<p><font color="#000000">Если кодируемый текст
не находится в канонической форме.
то перед конвертацией в Base64
необходимо сначала все концы строк
заменить стандартной
последовательностью CRLF.
Предпочтительнее эту функцию
встроить в кодировщик Base64, нежели
заставлять пользователя
производить предварительную
канонизацию текста другими
средствами. </font></p>

<p><font color="#000000">Нет нужды
экранировать вложенные тела внутри
многочастного тела (multipart) при
кодировании его в Base64, так как в
коде Base64 отсутствует символ '-'. </font></p>

Source: http://kunegin.com/ref2/email/mime03.htm